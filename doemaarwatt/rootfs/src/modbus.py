from pymodbus.client import AsyncModbusTcpClient, ModbusException
from pymodbus.payload import BinaryPayloadDecoder
from pymodbus.constants import Endian
from config import config
from typing import Any


_modbus_exception_codes = {
    0x01: 'Illegal function code',
    0x02: 'Illegal data address',
    0x03: 'Illegal data value',
    0x04: 'Server failure during execution',
    0x05: 'Acknowledge (server accepted service invocation but requires a long time to execute. Server therefore only returns an acknowledgement',
    0x06: 'Server busy',
    0x07: 'Negative acknowledge from server',
    0x08: 'Memory parity error',
    0x0A: 'Gateway problem (gateway paths not avialable)',
    0x0B: 'Gateway problem (targeted device failed to respond. Exception generated by gateway)',
}


class ModbusManager():

    def __init__(self):
        self._clients: dict[str, AsyncModbusTcpClient] = {}

        for inv_name in config.get_inverter_names():
            inv_config = config.inverter_config(inv_name)
            if inv_config['host'].lower() in ['test', 'debug']:
                print(f'DEBUG: creating dummy client for {inv_name}')
                self._clients[inv_name] = None
            else:
                print(f'DEBUG: creating modbus client for {inv_name}')
                self._clients[inv_name] = AsyncModbusTcpClient(
                    inv_config['host'],
                    port=int(inv_config['port']),
                    name=f'Modbus[{inv_name}]',
                    reconnect_delay=f'10.0',  # TODO: make config setting
                    timeout=5,
                )

    async def connect(self):
        for name, client in self._clients.items():
            print(f'DEBUG: connecting to inverter {name}')
            if client is None:
                continue
            await client.connect()
            if not client.connected:
                raise Exception(f'unable to connect to inverter {name}')

    def close(self):
        for client in self._clients.values():
            if client is None:
                continue
            client.close()

    async def write_registers(self,
        address: int,
        values: list[int],
        no_response_expected: bool = False,
    ):
        for name, client in self._clients.items():
            print(f'DEBUG: Modbus[{name}] write registers {address} -> {values}')
            if client is None:
                continue
            await client.write_registers(
                address,
                values,
                device_id=3,  # battery-management also uses slave=3. Perhaps related to Unit ID in datasheet?
                no_response_expected=no_response_expected,
            )

    async def _read_registers(self,
        client_name: str,
        address: int,
        dtype: str,
        result_dict: dict[str, Any],
        device_id: int = 3,
        sma_data_format: str | dict[int, str] | None = None,
    ):
        '''
        Read a holding or input register using the client connected to client_name
        The following logic is used to determine whether the register is a holding or input register:

        3x = Input Register = 30001-39999
        4x = Holding Register = 40001-49999
        '''
        print(f'DEBUG: Modbus[{client_name}] trying to read register {address}')
        result_dict[client_name] = None  # ensure some value is present
        client = self._clients.get(client_name)
        if client is None:
            return

        try:
            ra = self._get_relative_address(address)
            cnt = self._dtype_to_word_count(dtype)

            if str(address)[0] == '4':
                resp = await client.read_holding_registers(ra, count=cnt, device_id=device_id)
            elif str(address)[0] == '3':
                resp = await client.read_input_registers(ra, count=cnt, device_id=device_id)

            if resp.isError():
                exc_descr = _modbus_exception_codes.get(resp.exception_code, '<unknown>')
                raise Exception(f'modbus error while reading from {client_name}: ({resp.exception_code}) {exc_descr}')

            value = self._decode_response(dtype, resp, sma_data_format=sma_data_format)
            result_dict[client_name] = value
            print(f'DEBUG: Modbus[{client_name}] read register {address} -> {value}')

        except ModbusException as e:
            raise Exception(f'internal exception in Pymodbus library while reading from {client_name}: {e}')

    async def read_registers(self,
        address: int,
        dtype: str,
        device_id: int = 3,
        sma_data_format: str | dict[int, str] | None = None,
    ) -> dict[str, Any]:
        '''Perform a parallel register read operation across all clients'''
        ret = {}  # collect results here

        tasks = []
        for name, client in self._clients.items():
            if client is None:
                continue
            tasks.append(self._read_registers(name, address, dtype, ret, device_id=device_id, sma_data_format=sma_data_format))

        try:
            await asyncio.gather(*tasks)  # exceptions raised within a task will propagate
        except Exception as e:
            print(f'DEBUG: Modbus parallel read failed: {e}')
            self.close()
            raise

        return ret

    def _dtype_to_word_count(self, dtype: str) -> int:
        dtype = dtype.upper()
        if dtype == 'U16':
            return 1
        elif dtype == 'S16':
            return 1
        elif dtype == 'U32':
            return 2
        elif dtype == 'S32':
            return 2
        elif dtype == 'U64':
            return 4
        elif dtype == 'S64':
            return 4
        raise Exception(f'unrecognized Modbus datatype: {dtype}')

    def _decode_response(self,
        dtype: str,
        resp,
        sma_data_format: str | dict[int, str] | None = None,
    ) -> Any:
        '''
        Decode a non-error modbus server response according to the datatype, applying proper endianness, etc
        See https://www.pymodbus.org/docs/reading-registers#working-with-different-data-types
        '''
        dtype = dtype.upper()
        if dtype == 'U16':
            value = int(resp.registers[0])
        elif dtype == 'S16':
            value = int(resp.registers[0])
            value = value if value < 32768 else value - 65536  # Convert to signed
        elif dtype == 'U32':
            decoder = BinaryPayloadDecoder.fromRegisters(resp.registers, byteorder=Endian.BIG, wordorder=Endian.BIG)
            value = decoder.decode_32bit_uint()
        elif dtype == 'S32':
            decoder = BinaryPayloadDecoder.fromRegisters(resp.registers, byteorder=Endian.BIG, wordorder=Endian.BIG)
            value = decoder.decode_32bit_int()
        elif dtype == 'U64':
            decoder = BinaryPayloadDecoder.fromRegisters(resp.registers, byteorder=Endian.BIG, wordorder=Endian.BIG)
            value = decoder.decode_64bit_uint()
        else:  # TODO expand for STR32 type and variable length strings
            return resp

        if sma_data_format is not None:
            sma_data_format = sma_data_format.upper()
            if sma_data_format == 'FIX0':
                pass  # no decimal place, so no rounding needed
            elif sma_data_format == 'FIX1':
                value = float(value) / 1e1
            elif sma_data_format == 'FIX2':
                value = float(value) / 1e2
            elif sma_data_format == 'FIX3':
                value = float(value) / 1e3
            elif sma_data_format == 'TEMP':
                value = float(value) / 1e1
            elif isinstance(sma_data_format, dict):  # assuming data format is a tag list mapping
                try:
                    value = sma_data_format[value]
                except KeyError:
                    raise Exception(f'no taglist mapping for value {value}')

        print(f"DEBUG: decoded response '{resp}' into {value}")
        return value

    def _get_relative_address(self, address: int) -> int:
        '''
        Interpret addresses using the following scheme:

        3x = Input Register = 30001-39999
        4x = Holding Register = 40001-49999
        '''
        addr_str = str(address)
        addr_digits = len(addr_str)  # eg. 5 for address '40141'
        base_mult = 10 ** (addr_digits - 1)

        if addr_str[0] == '4':
            base = 4 * base_mult + 1
            return address - base

        if addr_str[0] == '3':
            base = 3 * base_mult + 1
            return address - base

        raise Exception(f'unable to determine relative address for {address}')
